from datetime import datetime, date
from typing import Optional
from sqlmodel import Relationship, Field, SQLModel, create_engine, Session, select

# ------------------------------------- #
#            database models            #
# ------------------------------------- #
# back_populates="" tells SQLModel that if something changes in this model, it should change that attribute in the other model,
# and it will work even before committing with the session (that would force a refresh of the data).

class BookAuthorLinkInDB(SQLModel, table=True):
     """Database model for many-to-many relation of books to authors."""

     __tablename__ = "book_author_links"

     book_id: int = Field(foreign_key="books.id", primary_key=True)
     author_id: int = Field(foreign_key="authors.id", primary_key=True)

    #  book: "BookInDB" = Relationship(back_populates="authors")
    #  author: "AuthorInDB" = Relationship(back_populates="books")

class UserBookLinkInDB(SQLModel, table=True):
    """Database model for many-to-many relation of users to books."""

    __tablename__ = "user_books_links"

    user_id: int = Field(foreign_key="users.id", primary_key=True)
    book_id: int = Field(foreign_key="books.id", primary_key=True)

    # book: "BookInDB" = Relationship(back_populates="users")
    # user: "UserInDB" = Relationship(back_populates="books")


class UserInDB(SQLModel, table=True):
    """Database model for a user."""

    __tablename__ = "users"

    id: Optional[int] = Field(default=None, primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    username: str = Field(unique=True, index=True) # index will be created on the username col, which helps speed up queries that search for users by username
    first_name: str = None
    email: str = Field(unique=True)
    hashed_password: Optional[str] = None
    created_at: Optional[datetime] = Field(default_factory=datetime.now) # field value generated by database once saved

    # Many to many between Users and Books
    books: list["BookInDB"] = Relationship(back_populates="users",
                                           link_model=UserBookLinkInDB) # Specifies the Join table
    
    # One to many between Users and Goals
    goals: list["GoalInDB"] = Relationship(back_populates="user")

class BookInDB(SQLModel, table=True):
    """Database model for a book."""

    __tablename__ = "books"

    id: str = Field(primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    title: str = Field(index=True) #indexing makes searching by title more efficient 
    subtitle: Optional[str] = None
    published: Optional[str] = None
    description: Optional[str] = None
    page_count: Optional[int] = None
    cover_url: Optional[str] = None

    # Many to many between Books and Authors
    authors: list["AuthorInDB"] = Relationship(back_populates="books",
                                             link_model=BookAuthorLinkInDB) # Specifies the Join table
    
    # Many to many between Books and Users
    users: list["UserInDB"] = Relationship(back_populates="books",
                                           link_model=UserBookLinkInDB) # Specifies the Join table
    
    # between Books and Goals
    goals: list["GoalInDB"] = Relationship(back_populates="book")

class AuthorInDB(SQLModel, table=True):
    """Database model for an author."""

    __tablename__ = "authors"

    id: Optional[int] = Field(default=None, primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    name: str = Field(index=True, unique=True) #indexing makes searching by author more efficient 

    # The string in back_populates="authors" refers to the attribute authors in the class BookInDB (the other class).
    # Many to many between Authors and Books
    books: list["BookInDB"] = Relationship(back_populates="authors",
                                           link_model=BookAuthorLinkInDB) # Specifies the Join table

class GoalInDB(SQLModel, table=True):
    start_date: Optional[datetime] = None
    current_page: Optional[int] = 0
    finish_date: Optional[datetime] = None
    pages_per_day: Optional[int] = None

    book_id: int = Field(foreign_key="books.id", primary_key=True)
    user_id: int = Field(foreign_key="users.id", primary_key=True)

    # Many to One between Goals and Users
    user: UserInDB = Relationship(back_populates="goals")

    # Many to One between Goals and Books
    book: BookInDB = Relationship(back_populates="goals")

# ------------------------------------- #
#            Request models             #
# ------------------------------------- #

class UserRegistration(SQLModel):
    """Request model to register a new user."""

    first_name: str
    username: str
    email: str
    password: str

# ------------------------------------- #
#            Response models            #
# ------------------------------------- #

class UserResponse(SQLModel):
    """Response model for a user"""
    first_name: str
    username: str
    email: str



# sqlite_file_name = "database.db"
# sqlite_url = f"sqlite:///{sqlite_file_name}"
# connect_args = {"check_same_thread": False}
# engine = create_engine(sqlite_url, echo=True, connect_args=connect_args)


# def create_db_and_tables():
#     SQLModel.metadata.create_all(engine)

# def create_books_and_authors():
#     jk_rowling = AuthorInDB(name="JK Rowling")
#     colleen_hoover = AuthorInDB(name="Colleen Hoover")

#     harry_potter1 = BookInDB(id="1rosnkmJ0Ko", title="Harry Potter and the Sorcerer's Stone", published="2013-08-27", description="Rescued from the outrageous neglect of his aunt and uncle, a young boy with a great destiny proves his worth while attending Hogwarts School for Witchcraft and Wizardry.", page_count=336, authors=[jk_rowling])
#     harry_potter2 = BookInDB(id="5iTebBW-w7QC", title="Harry Potter and the Chamber of Secrets", published="2015-12-08", description="There is a plot, Harry Potter. A plot to make most terrible things happen at Hogwarts School of Witchcraft and Wizardry this year. Harry Potter's summer ... ", page_count=344, authors=[jk_rowling])
#     harry_potter3 = BookInDB(id="Sm5AKLXKxHgC", title="Harry Potter and the Prisoner of Azkaban", published="2015-12-08", description="Lorem Ipsuum... ", page_count=445, authors=[jk_rowling])
#     it_ends = BookInDB(id="wmnuDwAAQBAJ", title="It Ends With Us", published="2020-07-28", description="In this â€œbrave and heartbreaking novel that digs its claws ... ", page_count=448, authors=[colleen_hoover])

#     with Session(engine) as session:
#         session.add(harry_potter1)
#         session.add(harry_potter2)
#         session.add(harry_potter3)
#         session.add(it_ends)
#         session.commit()

# def create_user():
#     rachel = UserInDB(username="rachel", first_name="rachel", email="rachel@gmail.com")
#     with Session(engine) as session:
#         session.add(rachel)
#         session.commit()

#         session.refresh(rachel)

# def add_book():
#     book = BookInDB(id="wmDwAAQBAJ", title="Title", page_count=100)
#     with Session(engine) as session:
#         session.add(book)
#         session.commit()


# def add_user_book():
#     book = BookInDB(id="22", title="Blah", published="2013-08-27", description="Rescued from the outrageous neglect of his aunt and uncle, a young boy with a great destiny proves his worth while attending Hogwarts School for Witchcraft and Wizardry.", page_count=336, authors=[AuthorInDB(name="Smith")])
#     with Session(engine) as session:
#         update_user = session.exec(select(UserInDB).where(UserInDB.username=="rachel")).one()
#         update_user.books.append(book)
#         session.add(update_user)
#         session.commit()


# def main():  
#     create_db_and_tables()  
#     create_books_and_authors()  
#     create_user()
#     add_user_book()
#     # add_book()


# if __name__ == "__main__":  
#     main()  


