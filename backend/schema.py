from datetime import datetime, date
from typing import Any, Optional, Union
from pydantic import BaseModel
from sqlmodel import Relationship, Field, SQLModel, create_engine, Session, select

# ------------------------------------- #
#            database models            #
# ------------------------------------- #
# back_populates="" tells SQLModel that if something changes in this model, it should change that attribute in the other model,
# and it will work even before committing with the session (that would force a refresh of the data).

class BookAuthorLinkInDB(SQLModel, table=True):
     """Database model for many-to-many relation of books to authors."""

     __tablename__ = "book_author_links"

     book_id: int = Field(foreign_key="books.id", primary_key=True)
     author_id: int = Field(foreign_key="authors.id", primary_key=True)

    #  book: "BookInDB" = Relationship(back_populates="authors")
    #  author: "AuthorInDB" = Relationship(back_populates="books")

class UserBookLinkInDB(SQLModel, table=True):
    """Database model for many-to-many relation of users to books."""

    __tablename__ = "user_books_links"

    user_id: int = Field(foreign_key="users.id", primary_key=True)
    book_id: int = Field(foreign_key="books.id", primary_key=True)

    start_date: Optional[datetime]

    # book: "BookInDB" = Relationship(back_populates="users")
    # user: "UserInDB" = Relationship(back_populates="books")


class UserInDB(SQLModel, table=True):
    """Database model for a user."""

    __tablename__ = "users"

    id: Optional[int] = Field(default=None, primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    username: str = Field(unique=True, index=True) # index will be created on the username col, which helps speed up queries that search for users by username
    first_name: str = None
    email: str = Field(unique=True)
    hashed_password: Optional[str] = None
    created_at: Optional[datetime] = Field(default_factory=datetime.now) # field value generated by database once saved

    # Many to many between Users and Books
    books: list["BookInDB"] = Relationship(back_populates="users",
                                           link_model=UserBookLinkInDB) # Specifies the Join table
    
    # One to many between Users and Goals
    goals: list["GoalInDB"] = Relationship(back_populates="user")

class BookInDB(SQLModel, table=True):
    """Database model for a book."""

    __tablename__ = "books"

    id: str = Field(primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    title: str = Field(index=True) #indexing makes searching by title more efficient 
    subtitle: Optional[str] = None
    published: Optional[str] = None
    description: Optional[str] = None
    page_count: Optional[int] = None
    cover_url: Optional[str] = None

    # Many to many between Books and Authors
    authors: list["AuthorInDB"] = Relationship(back_populates="books",
                                             link_model=BookAuthorLinkInDB) # Specifies the Join table
    
    # Many to many between Books and Users
    users: list["UserInDB"] = Relationship(back_populates="books",
                                           link_model=UserBookLinkInDB) # Specifies the Join table
    
    # between Books and Goals
    goals: list["GoalInDB"] = Relationship(back_populates="book")

class AuthorInDB(SQLModel, table=True):
    """Database model for an author."""

    __tablename__ = "authors"

    id: Optional[int] = Field(default=None, primary_key=True) # value of id will be None until we save it in the database (where it will be generated by the database)
    name: str = Field(index=True, unique=True) #indexing makes searching by author more efficient 

    # The string in back_populates="authors" refers to the attribute authors in the class BookInDB (the other class).
    # Many to many between Authors and Books
    books: list["BookInDB"] = Relationship(back_populates="authors",
                                           link_model=BookAuthorLinkInDB) # Specifies the Join table

class GoalInDB(SQLModel, table=True):

    __tablename__ = "goals"

    start_date: Optional[datetime] = None
    current_page: Optional[int] = 0
    finish_date: Optional[datetime] = None
    pages_per_day: Optional[int] = None

    book_id: int = Field(foreign_key="books.id", primary_key=True)
    user_id: int = Field(foreign_key="users.id", primary_key=True)

    # Many to One between Goals and Users
    user: UserInDB = Relationship(back_populates="goals")

    # Many to One between Goals and Books
    book: BookInDB = Relationship(back_populates="goals")

# ------------------------------------- #
#            Request models             #
# ------------------------------------- #

class UserRegistrationRequest(SQLModel):
    """Request model to register a new user."""

    first_name: str
    username: str
    email: str
    password: str

# ------------------------------------- #
#            Response models            #
# ------------------------------------- #

class UserResponse(SQLModel):
    """Response model for a user"""
    first_name: str
    username: str
    email: str

class Author(BaseModel):
    """Model for an author"""

    name: Optional[str]

class AuthorCollection(BaseModel):
     """Model for a collection of authors"""
     
     authors: Optional[list[Author]]

class Book(BaseModel):
    """Model for a book"""
    id: Optional[str]
    title: Optional[str]
    subtitle: Optional[str]
    published: Optional[str]
    description: Optional[str]
    page_count: Optional[int]
    cover_url: Optional[str]
    authors: Optional[list[Union[str, AuthorInDB]]]


class BookCollectionResponse(BaseModel):
    """Response model for a collection of books"""

    books: list[Book] = []


class User(BaseModel):
    """Response model for user"""

    user_id: Optional[int]
    username: Optional[str]


